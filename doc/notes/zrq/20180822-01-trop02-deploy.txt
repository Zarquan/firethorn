#
# <meta:header>
#   <meta:licence>
#     Copyright (c) 2018, ROE (http://www.roe.ac.uk/)
#
#     This information is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     This information is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
#   </meta:licence>
# </meta:header>
#
#
    
    Delete all the virtual machines
    Reboot the physical machine
    Create a new set of virtual machines

        Install OSA TAP service
        Install Genius TAP service
        Install Apache proxy

    Test using metagrid DNS entry
    
    Move the external floating IP address from trop01 to trop02.
    Test using roe DNS entry



# -----------------------------------------------------
# Check the local libvirt settings.
#[user@trop]

    cat "${HOME}/libvirt.settings"

         : ${basepool:='base'}
         : ${livepool:='live'}
         : ${connection:='qemu:///system'}
        export basepool
        export livepool
        export connection

# -----------------------------------------------------
# List the existing VMs.
#[user@trop]

    source "${HOME}/libvirt.settings"
    virsh \
        --quiet \
        --connect "${connection}" \
        list \
    | sed 's/.*\([0-9]\{1,\}\) *\([a-zA-Z]\{1,\}\) *\([a-z]\{1,\}\).*/\2/' \
    | tee vm-list.txt

# -----------------------------------------------------
# Delete the existing VMs.
#[user@trop]

    source "${HOME}/libvirt.settings"

    for vmname in $(cat vm-list.txt)
    do
        echo "${vmname:?}"
        virsh \
            --quiet \
            --connect "${connection}" \
            destroy "${vmname:?}"

        virsh \
            --quiet \
            --connect "${connection}" \
            undefine "${vmname:?}"
    done

# -----------------------------------------------------
# Create a new VM.
#[user@trop]

    createvm

        INFO : Node name [Siamond]
        INFO : Base name [fedora-28-docker-base-20180708.qcow]
        INFO : Base path [/var/lib/libvirt/images/base/fedora-28-docker-base-20180708.qcow]
        INFO : Disc name [Siamond.qcow]
        INFO : Disc size [16GiB]

# -----------------------------------------------------
# Login as Stevedore
#[user@trop]

    ssh Siamond

# -----------------------------------------------------
# Add our secret function.
#[user@virtual]

    mkdir "${HOME:?}/bin"
    cat > "${HOME:?}/bin/secret" << 'EOF'

secret()
    {
    local key=${1:?}
    local server='dave@shepseskaf.roe.ac.uk'
    ssh -o 'VisualHostKey=no' "${server:?}" "bin/secret \"${key:?}\""
    }

if [ -n "${1}" ]
then
    secret "${1}"
fi
EOF

    chmod u+x "${HOME:?}/bin/secret"
    secret 'frog'

# -----------------------------------------------------
# Set the target version.
#[user@virtual]

    export buildtag=2.1.25

# -----------------------------------------------------
# Remove existing containers. (Not needed for new VM)
#[user@virtual]

    #docker rm -vf $(docker ps -aq)

# -----------------------------------------------------
# Remove existing images. (Not needed for new VM)
#[user@virtual]

    #docker rmi -f $(docker images -q)

# -----------------------------------------------------
# Create our chain properties.
#[user@virtual]

    cat > "${HOME:?}/chain.properties" << EOF

        buildtag=${buildtag:?}

        metadata=data_$(pwgen 10 1)
        metauser=user_$(pwgen 10 1)
        metapass=$(pwgen 20 1)

        usertype=$(secret 'firethorn.user.type')
        userhost=$(secret 'firethorn.user.host')
        userdata=$(secret 'firethorn.user.data')
        useruser=$(secret 'firethorn.user.user')
        userpass=$(secret 'firethorn.user.pass')

        datauser=$(secret 'firethorn.data.user')
        datapass=$(secret 'firethorn.data.pass')

        admingroup=group-$(pwgen 10 1)
        adminuser=admin-$(pwgen 10 1)
        adminpass=$(pwgen 20 1)

        guestgroup=group-$(pwgen 10 1)
        guestuser=guest-$(pwgen 10 1)
        guestpass=$(pwgen 20 1)

        #tapschemadata=data_$(pwgen 10 1)
        tapschemadata=postgres
        tapschemauser=user_$(pwgen 10 1)
        tapschemapass=$(pwgen 20 1)
        tapschemajdbc=jdbc_$(pwgen 10 1)

        adql_query_delay_first=10

        firethorn_limits_rows_absolute=10000000
        firethorn_limits_rows_default=100000

EOF

# -----------------------------------------------------
# Link our compose config.
#[user@virtual]

    ln -sf "${HOME:?}/chain.properties" "${HOME:?}/.env"

# -----------------------------------------------------
# Download the latest version of our compose file.
#[user@virtual]

    wget 'http://wfau.metagrid.co.uk/code/firethorn/raw-file/tip/docker/compose/tap-deployer.yml'

# -----------------------------------------------------
# Start our containers ...
#[user@virtual]

    docker-compose \
        --file "tap-deployer.yml" \
        run \
            firethorn-py

# -----------------------------------------------------
# Run our Python installer.
#[python]

import os
import uuid
import time
import firethorn as ftpy
import firethorn_utils.configurator as configur

#
# Create our Firethorn client.
firethorn = ftpy.Firethorn(
    endpoint = os.environ.get(
        'endpoint'
        )
    )

#
# Login as the admin account.
firethorn.login(
    os.environ.get('adminuser'),
    os.environ.get('adminpass'),
    os.environ.get('admingroup')
    )

#
# Create our Configurator.
configurator = configur.Configurator(
    firethorn
    )

#
# Load the OSA configutarion.
configurator.load_resources(
    "https://raw.githubusercontent.com/wfau/metadata/master/firethorn/config/osa-tap.json"
    )

# -----------------------------------------------------
# Run our Python tests.
#[python]

#
# Get the Atlas AdqlResource from our Configurator.



#
# Login using a guest account.
firethorn.login(
    str(uuid.uuid4()),
    str(uuid.uuid4()),
    None
    )

#
# Create a new workspace.
workspace = firethorn.firethorn_engine.create_adql_resource(
    "Query resource"
    )

#
# Import the ATLAS schemas into our workspace
for schema in atlas_adql.select_schemas():
    workspace.import_adql_schema(
        schema
        )

#
# Create and run a query.
query_str = "SELECT TOP 1000 ra, dec FROM ATLASDR1.atlasSource"
query_obj = workspace.create_query(
    query_str,
    "COMPLETED",
    None,
    3000000
    )
print(
    query_obj
    )
print(
    query_obj.table()
    )
print(
    query_obj.table().count()
    )

#
# Iterate the metadata tree
for schema in atlas_adql.select_schemas():
    for table in schema.select_tables():
        print(
            "table  [{}][{}]".format(
                schema.name(),
                table.name()
                )
            )
        query_str = "SELECT TOP 10 * FROM {}.{}".format(
            schema.name(),
            table.name()
            )
        query_obj = workspace.create_query(
            query_str,
            "COMPLETED",
            None,
            3000000
            )
        py_table = query_obj.table().as_astropy()
        py_table.pprint()




#
# Run some queries in parallel
from concurrent.futures import ThreadPoolExecutor
import concurrent.futures

query_str = "SELECT TOP 10000 ra, dec FROM ATLASDR1.atlasSource"

def do_query(workspace, query_str, limit, delay):
    query_obj = workspace.create_query(
        query_str,
        "COMPLETED",
        None,
        200000,
            {
            "adql.query.limit.rows"  : limit,
            "adql.query.delay.every" : delay
            }
        )
    return query_obj.json_object.get("results").get("count")

def do_queries(workspace, query_str, threads, delay):
    with concurrent.futures.ThreadPoolExecutor(threads) as executor:
        futures = {
            executor.submit(
                do_query,
                workspace,
                query_str,
                limit,
                delay
                ): limit for limit in range(threads, 0, -1)
            }
        for future in concurrent.futures.as_completed(futures):
            print(
                future.result()
                )

for threads in range(1, 20):
    for delay in range(500, -100, -100):
        print("---- ", threads, delay)
        do_queries(
            workspace,
            query_str,
            threads,
            delay
            )


#
# Exit the Python shell

    Ctrl^D







# -----------------------------------------------------
# Separate shell to monitor the logs
#[user@trop]

    ssh Siamond

        su -s
        
            container=stevedore_gillian_1
            
            pushd $(
                docker inspect \
                    "${container:?}" \
              | jq -r '
                    .[].Mounts | .[] | select(.Destination == "/var/local/tomcat/logs") | .Source
                    '
                    )

            tail -f firethorn-debug.log



$def with (survey_prefix)
<script src="$survey_prefix/static/js/scrolling_helper.js" type="text/javascript" charset="utf-8"></script>
<link href="$survey_prefix/static/css/sqlcookbook.css" media="screen" rel="stylesheet" type="text/css"/>  

<script type="text/javascript">
		var this_div_name = 'sqlcookbook';
		init_scrolling_mechanism(this_div_name);
		 jQuery('.list > li a').click(function() {
			 jQuery(this).parent().find('ul').slideToggle("slow");
		    });
</script>


<div id="content_sqlcookbook">
	<div class="fixed_menu_left" id="accordion">

		<h2>Contents</h2>
		<ul class="list">
			
			<li><a href="#Introduction">1.Introduction</a></li>
			<li><a href="#Primer">2. Primer</a>
				<ul style="display:none;">	
		
					<li><a href="#Relational databases">2.1 Relational databases</a></li>
					<li><a href="#The OSA as a relational database">2.2 The OSA
							as a relational database</a></li>
					<li><a href="#Structured Query Language (SQL)">2.3
							Structured Query Language (SQL)</a></li>
					<li><a href="#The basic structure of a OSA SQL statement">2.4
							The basic structure of a OSA SQL statement</a></li>
					<li><a href="#Null and default values in the OSA">2.5 Null
							and default values in the OSA</a></li>
				</ul></li>
			<li><a href="#Reference">3. Reference: additional options in <i>SELECT</i>
					statements
			</a>
				<ul style="display:none;">
					<li><a href="#Aggregate Functions">3.1 Aggregate functions</a></li>
					<li><a href="#Mathematical Functions">3.2 Mathematical
							functions</a></li>
					<li><a href="#Operators">3.3 Operators</a></li>
		
				</ul></li>
			<li><a href="#crossmatch">4. Querying cross-matched data</a>
				<ul style="display:none;">
					<li><a href="#Naming convention">4.1 Naming convention for
							tables and attributes</a></li>
					<li><a href="#Selecting nearby matches">4.2 Selecting nearby
							cross-matches</a></li>
					<li><a href="#Selecting the nearest matches">4.3 Selecting
							the nearest cross-match</a></li>
					<li><a href="#Selecting neighbours within one table">4.4
							Selecting neighbours within one table</a></li>
		
				</ul></li>
			<li><a href="#Quality flags">5. Refining sample selection
					using quality bit flags</a></li>
			<li><a href="#Filter cover">6. Refining sample selection for
					filter coverage</a></li>
		
		</ul>
	</div>
	
	<div class="cookbook_content">
		<h1>An Introductory SQL Tutorial for OSA Users</h1>
	
		<br /><br />
		<h2>
			1. <a name="Introduction">Introduction</a>
		</h2>
		
		<p>
			In this document we provide a brief introduction to the use of
			Structured Query Language (SQL) for accessing data in the OmegaCam
			Science Archive (OSA). Sections included in this document are a <strong><i><a
					href="#Primer">Primer</a></i></strong> aimed at users new both to the OSA and to
			SQL and a <strong><i><a href="#Reference">Reference</a></i></strong>
			which should be of use more experienced and returning users. Readers
			wanting a fuller introduction to SQL should consult <a
				href="http://sqlcourse2.com/other_links.html">an online tutorial</a>
			or one of the <a
				href="http://www.amazon.com/exec/obidos/search-handle-url/index=books&amp;field-keywords=SQL">legion
				of SQL books</a> available: <a
				href="http://www.oreilly.com/catalog/sqlnut/">O'Reilly's <em>SQL
					in a nutshell</em></a> is a good introduction. The document concludes with
			some examples of cross-querying VST and external survey data, which we
			expect to be a common usage of the archive.
		</p>
		
		<p>
			The OSA and its prototype, the <a href="http://surveys.roe.ac.uk/ssa">SuperCOSMOS
				Science Archive</a> (SSA) are large databases so, for test purposes, we
			have produced the &quot;Personal SSA&quot; (PSSA), which is a small
			subset of the SSA, containing solely the data in the region of the sky
			with 184 &lt; RA (deg) &lt; 186 and -1.25 &lt; Dec. (deg) &lt; 1.25,
			which is the same area of sky as the &quot;<a
				href="http://research.microsoft.com/~gray/SDSS/personal_skyserver.htm">Personal
				SkyServer</a>&quot; produced for the Early Data Release (<a
				href="http://skyserver.sdss.org/edr/en/">EDR</a>)of the Sloan Digital
			Sky Survey (<a href="http://www.sdss.org">SDSS</a>). The PSSA may be
			downloaded from <a href="http://surveys.roe.ac.uk/ssa/pssa.html">here</a>
			(as a .zip file with installation instructions included) or can be
			queried using a <a href="http://surveys.roe.ac.uk/ssa/sql.html">web
				interface</a> of the same form as for the full SSA. Similarly, the initial
			release of the OSA (which contains a limited amount of commissioning
			data) should be used if you are unfamiliar with SQL but wish to
			exercise queries on that database. <u><b>OSA and SSA users are
					strongly encouraged to use these small subsets for developing and
					debugging queries</b></u>: with databases as large as the OSA and full SSA it
			can take a long time to find out that the query you wrote does not do
			what you intended!
		</p>
		
		<p>
			This OSA Cookbook is based on the <a
				href="http://surveys.roe.ac.uk/ssa/sqlcookbook.html">SSA version</a>.
			Currently, the latter provides a more comprehensive introduction to SQL
			and in particular gives real-world examples of astronomy application
			queries that were used in the construction of the SSA. Novice users are
			strongly recommended to familiarise themselves with the PSSA and the
			information given in the SSA Cookbook before attempting real science
			with the OSA.
		</p>
		<br /><br />
		<h2>
			2.<a name="Primer"> Primer</a>
		</h2>
		
		<h3>
			2.1. <a name="Relational databases">Relational databases</a>
		</h3>
		
		<p>
			The OSA is a relational database, which means that it stores data in <i>tables</i>
			composed of <i>rows</i> and <i>columns</i>. Each row comprises the
			information stored for one data entry &#8211; e.g.. a celestial object
			in the case of the OSA &#8211; and there is one column for each of the
			<i>attributes</i> recorded for that entry &#8211; e.g. RA, Dec,
			ellipticity, etc. The different tables comprising a database may be
			linked (or <i>related</i>), if they each have columns representing the
			same data value (<i>integrity constraints</i> can be included in the
			table definitions which ensure consistency between two related tables,
			e.g. by preventing the deletion of only one of a pair of rows in
			different tables thus linked). For ease of use, it is possible to
			define virtual tables - called <i>views</i> - which are subsets of the
			data in one or more tables and which can be queried using the same
			syntax as ordinary tables (which are sometimes called <i>base</i>
			tables, to distinguish them from these virtual tables). In addition to
			tables and views, the major constituents of a relational database are <i>indexes</i>
			(the database community prefer that spelling to &quot;indices&quot;),
			which can speed up the identification of records which satisfy the
			particular condition expressed in a query, and various <i>stored
				procedures</i> and <i>functions</i> which extend the range of operations
			which can be performed on data held in the tables. The collection of
			definitions of columns, tables, views, indexes, stored procedures and
			functions in a database is called its <i>schema</i>.
		</p>
		
		<h3>
			2.2. <a name="The OSA as a relational database">The OSA as a
				relational database </a>
		</h3>
		
		<p>
			The OSA schema is described in detail 
			<a class="ext_links_sqlcookbook" href="#roe_browser_div">elsewhere</a>,
			but we recap here the basic features which we shall use later. For each
			VST survey programme in the OSA (e.g. the ATLAS Survey) two major
			tables called, for example, <i>vhsDetection</i> and <i>vhsSource</i>
			are available. The columns in <i>*Detection</i> are basically the
			attributes derived by running the pipeline image analyser over single
			passband frames, and these single-frame detections are then merged into
			multi-epoch, multi-colour records for individual celestial objects,
			which are stored in <i>*Source</i>. In addition to these major tables,
			there are also a number of metadata tables, which store ancillary
			information describing the processes involved in obtaining VST imaging
			data, and which enable the provenance of data values in <i>*Source</i>
			and <i>*Detection</i> to be traced all the way back to a given image.
			To aid spatial matching of objects within the OSA and between the OSA
			and external catalogue datasets (such as the 2MASS Point Source
			Catalogue and SDSS Data Release catalogues), there are also
			&quot;neighbour&quot; and &quot;cross-neighbour&quot; tables which
			record pairs of sources within 10 to 30 arcsec of one another,
			depending on the catalogues joined.
		</p>
		
		<h3>
			2.3. <a name="Structured Query Language (SQL)">Structured Query
				Language (SQL)</a>
		</h3>
		
		<p>
			SQL is the standard language for accessing and manipulating data stored
			in a relational database. In fact, several versions of the SQL standard
			exist, and most database management systems (DBMSs) actually support a
			subset of standard SQL, with some vendor-specific additions. The OSA is
			currently implemented in Microsoft's <a
				href="http://www.microsoft.com/sql">SQL Server 2000</a> DBMS, so OSA
			users will employ its SQL dialect (known as Transact-SQL, or T-SQL),
			although we have tried to restrict the use of vendor-specific features
			to a minimum. A fuller reference on T-SQL dialect than presented here
			is available online <a
				href="http://msdn2.microsoft.com/en-us/library/ms189826.aspx">
				here</a>.
		</p>
		
		<p>The first thing to understand about SQL is that it is a set-based
			language, not a procedural language, like Fortran or C. A user
			submitting an SQL query to a relational database is defining the set of
			properties of the records to be returned from the database, not
			specifying the list of operations which will lead to their delivery;
			this latter is the responsibility of the DBMS engine, which will decide
			the best way to execute a given query from a set of possible execution
			plans. Many database vendors are adding procedural capabilities to the
			SQL dialects they support, and these constitute one of the main areas
			of difference between those dialects. These extensions will not be
			discussed here, as we shall concentrate on the basics of standard SQL.</p>
		
		<h3>
			2.4. <a name="The basic structure of a OSA SQL statement">The basic
				structure of a OSA SQL statement</a>
		</h3>
		
		<p>
			For security reasons, the OSA does not allow users to execute queries
			which affect the basic structure and contents of the database, only
			those which can extract data from it. In SQL terms, this means that
			only <i>SELECT</i> statements are allowed:<i> N.B</i>. in this tutorial
			we write all SQL keywords in upper case italics and some column names
			in mixed case, both for clarity, although the OSA's SQL dialect is case
			insensitive by default. There are three basic classes of <i>SELECT</i>
		
			statement:
		</p>
		
		<h4>2.4.1 Projections</h4>
		
		<p>
			A projection is the retrieval of a set of full columns from a table. To
			retrieve the nominal RAs and Decs of the centres of <i>all</i> VST
			ATLAS Survey fields in the OSA, one would type:
		</p>
		<!--<div style='border:solid; background-color: #ffffff'>-->
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT </i>ra, dec <i>FROM</i> atlasMergeLog
		
		</div>
		<p>
			where <i>atlasMergeLog</i> is the name of the OSA table which records
			information about ATLAS fields, and <i>ra</i> and <i>dec</i> are the
			names of the relevant columns in that table.
		</p>
		
		<h4>2.4.2 Selections</h4>
		
		<p>A selection is the retrieval of the data values in particular
			columns for those rows in a table which satisfy certain criteria. So,
			if one were interested only in fields whose nominal centres lie in a 1
			degree strip on the celestial equator, the appropriate SQL query would
			be:</p>
		
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> ra, dec<br> <i>FROM</i> atlasMergeLog<br> <i>WHERE</i>
			dec <i>BETWEEN</i> -0.5 <i>AND</i> +0.5
		
		</div>
		<p>
			In this example the SQL statement has been split into three lines to
			emphasise the <i>SELECT&#8230;FROM&#8230;WHERE</i> syntax, but this is
			still one SQL statement. The SQL Query Form in the OSA interface
			ignores the whitespace at the end of each line of text and generates a
			single query string from valid multi-line text like this. (Note that
			this means that users should <i>not</i> used double hyphens to indicate
			comments in multi-line queries, since this will result in all text
			after the first comment being ignored.) <br> Multiple constraints
			can be included in the <i>WHERE </i>clause of a selection, so, for
			example, the query above could be rewritten as:
		</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> ra, dec <i>FROM</i> atlasMergeLog <i>WHERE</i> (dec &gt;=
			-0.5) <i>AND</i> (dec &lt;= +0.5)
		</div>
		<p>while the centres of all other fields could be selected using the
			following statement:</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> ra, dec <i>FROM</i> atlasMergeLog <i>WHERE</i> (dec &lt;
			-0.5) <i>OR</i> (dec &gt; +0.5)
		</div>
		<p>
			The parentheses in these examples have been included for clarity
			&#8211; they are only <i>required</i> when needed to avoid ambiguity,
			and when necessary to over-rule the standard order of precedence
			amongst operators, outlined in <a href="#Operator precedence">Section
				3.3.6</a> (users should note that the accidental omission of the <i>WHERE</i>
			clause from a selection turns it not into an invalid query, but into
			the projection of the columns contained in its <i>SELECT</i> clause,
			which, for tables as large as the <i>*Source</i> and <i>*Detection</i>
			tables of the OSA will return a lot of data). Note the units of
			spherical coordinates in the OSA: these are almost always decimal
			degrees for both RA and Dec (a notable exception to this rule is
			attribute <i>raBase</i> in table <i>Multiframe</i>, where the units are
			hours for consistency with the FITS files ingested from the processing
			centre. You can easily convert units in selections or <i>WHERE</i>
			clauses: e.g. <i>SELECT</i> raBase*15.0 ..., or <i>WHERE</i> (ra/15.0)
			&gt; 23.0 ... etc.
		</p>
		
		<p>
			Note that users should check which attributes in which tables have been
			indexed in the OSA, since the performance of queries that can make use
			of them should be significantly better than for those which do not:
			this information is presented in the 
			<a class="ext_links_sqlcookbook"  href="#roe_browser_div">Schema
				Browser</a> as highlighted rows in the lists of table attributes.
		</p>
		
		<h4>2.4.3 Joins</h4>
		
		<p>
			A join is the retrieval of data entries from one or more tables in a
			database matched under some criterion. Extending our example above, a
			user may be interested in the dates on which the Y band images in a
			strip were taken. The <i>Multiframe</i> table in the OSA has an
			attribute called <i>mjdObs,</i> which records the Modified Julian Date
			of the observation. The <i>*MergeLog</i> and <i>Multiframe</i> tables
			are linked by having the common attribute <i>multiframeID</i>, which is
			a unique identifier for each FITS file ingested into the archive. The
			SQL query retrieving the desired dates here would be:
		</p>
		
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> mjdObs, ra, dec<br> <i>FROM</i> atlasMergeLog,
			Multiframe <br> <i>WHERE</i> (dec <i>BETWEEN</i> -0.5 <i>AND</i>
			+0.5) <br> <i>AND</i> (ymfID = multiframeID) <i>AND</i> (ymfID
			&gt; 0)
		</div>
		<p>
			In this query, records in the <i>Multiframe </i>table and the <i>atlasMergeLog</i>
			table are being joined on condition that their values for the <i>multiframeID</i>
		
			attribute are equal. Furthermore, we select only those rows for which
			there is a Y multiframe identifier, i.e. we exclude any rows where
			there is no Y multiframe in the merged frame set. Such a situation is
			indicated by a default value for the attribute (see <a
				href="#Null and default values in the OSA">Section 2.5</a>.). Note
			also that in general, FITS files produced by the pipeline are
			multi-extension files containing a paw-print of 4 individual images,
			and fields in the merge logs are made up from sets of individual images
			in different passbands and at different epochs. The observation dates
			of the four paw-print images will be nearly the same, so the results
			set should contain sets of four repeats of the observation dates
			matched with the different centres of the device images that comprise
			the multiframe.
		</p>
		
		<p>
			The <i>AS</i> keyword can be used to rename the attributes in the <i>SELECT
			</i>clause so that their names in the output result set differs from those
			by which they are known in the database table. For example, a user
			thinking that the column names referred to in the query above are a
			little cryptic could rewrite it as follows:
		</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> mjdObs <i>AS</i> yModifiedJulianDate, ra <i>AS</i>
			fieldCentreRA, dec <i>AS</i> fieldCentreDec<br> <i>FROM</i>
			atlasMergeLog, Multiframe <br> <i>WHERE</i> (dec <i>BETWEEN</i>
			-0.5 <i>AND</i> +0.5) <br> <i>AND</i> (ymfID = multiframeID) <i>AND</i>
			(ymfID &gt; 0)
		</div>
		<p>
			and the columns returned in the output result set will be headed <i>yModifiedJulianDate</i>,
			<i>fieldCentreRA</i>, <i>fieldCentreDec</i>. This useful facility can
			be misused by the unwary or the very stupid. For example, it would be
			possible to have a query which started "<i>SELECT</i> ra <i>AS</i> dec,
			dec <i>AS</i> ra", which could confuse the subsequent analysis of the
			extracted result set. In the particular case of extracting data in <a
				href="http://vizier.u-strasbg.fr/doc/VOTable/votable-1-0.htx">VOTable</a>
			format from the OSA, the assignment of Unified Content Descriptors (<a
				href="http://vizier.u-strasbg.fr/UCD/">UCDs</a>) to columns - i.e.
			setting the values of the <i>ucd </i>attributes to <i>&lt;FIELD&gt;</i>
			elements in the metadata section at the start of the VOTable document -
			is performed on the basis of the column name in the output result set,
			so a user swapping <i>ra</i> and <i>dec</i>, as in the example above,
			would end up with the wrong UCD for both those two columns, causing
			problems were that VOTable to be used in conjunction with other Virtual
			Observatory tools reliant on UCDs. For the moment, users wishing to
			have UCDs included in VOTable output from the OSA must not rename table
			columns, while, more generally, it is left to the user to ensure that
			any renaming they do perform is sensible (note: UCDs in the SSA and OSA
			have been initially assigned according to the UCD1 definitions).
		</p>
		
		<p>It is also possible to write join queries in a way that makes it
			more explicit that they are joining the two tables, i.e. the example
			above becomes:</p>
		<div style="border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;">
			<i>SELECT</i> mjdObs, ra, dec<br> <i>FROM</i> Multiframe <br>
			<i>JOIN</i> atlasMergeLog <i>ON</i> (ymfID = multiframeID)<br> <i>WHERE</i>
			(dec <i>BETWEEN</i> -0.5 <i>AND</i> +0.5) <i>AND</i> (ymfID &gt; 0)
		</div>
		
		<p>
			This is an <i>inner join</i>, meaning it only returns the (<i>mjdObs</i>,<i>ra</i>,<i>dec</i>)
			triplets for matched rows, but there are other types of join, which
			return different combinations of data (see the <a
				href="http://surveys.roe.ac.uk/ssa/sqlcookbook.html">SSA Cookbook</a>
			for more details).
		</p>
		
		<h4>2.4.4 Subqueries</h4>
		
		<p>
			The SQL Server dialect of SQL allows the construction of nested <i>SELECT</i>
			statements, in which the <i>WHERE</i> clause includes a <i>subquery</i>
			which is itself a valid <i>SELECT</i> statement. For example, the join
			on <i>atlasMergeLog</i> and <i>Multiframe</i> in the previous Section
			could be rewritten in the following way:
		</p>
		
		<div style="border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;">
			<i>SELECT</i> mjdObs <br> <i>FROM </i>Multiframe<br> <i>WHERE</i>
			multiframeID <i>IN</i><br> (<i>SELECT</i> ymfID <i>FROM</i>
			atlasMergeLog <i>WHERE</i> (dec <i>BETWEEN</i> -0.5 <i>AND</i> +0.5) <i>AND</i>
			(ymfID &gt; 0))
		
		</div>
		<p>
			Note that the <i>ra</i> and <i>dec</i> attributes from the <i>atlasMergeLog</i>
			table have now been removed from the <i>SELECT</i> clause of the main
			query. This is because the <i>atlasMergeLog</i> table is only present
			in the subquery, and its attributes are no longer accessible to the
			main query. The one exception to this is its <i>ymfID</i> attribute,
			but that is only accessible by value - i.e. the subquery generates a
			list of <i>ymfID</i> values and matches between this and the <i>multiframeID</i>
			column of the <i>Multiframe</i> table are made by use of the <i>IN</i>
			operator. Note also that now the results set only contains the distinct
			values of the observation dates, i.e. we get one observation date per
			multiframe, as opposed to previously where the results sets contained
			repeated observation dates for the distinct device image centres.
		</p>
		
		<p>
			This query could also be written using a second logical operator, <i>ANY</i>,
			as follows:
		</p>
		
		<div style="border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;">
			<i>SELECT</i> mjdObs <br> <i>FROM </i>Multiframe<br> <i>WHERE</i>
			multiframeID = <i>ANY</i><br> (<i>SELECT</i> ymfID <i>FROM</i>
			atlasMergeLog <i>WHERE</i> (dec <i>BETWEEN</i> -0.5 <i>AND</i> +0.5) <i>AND</i>
			(ymfID &gt; 0))
		
		</div>
		<p>
			where the <i>ANY</i> operator is used to match rows in the <i>Multiframe</i>
			table with <i>any</i> of the rows in the output result set from the
			subquery which have the same <i>ymfID</i> value. Note that in both
			these subqueries formulations the list of attributes in the <i>SELECT</i>
			clause of the subquery must be consistent with the rest of the <i>WHERE</i>
			clause in the main query, since they are to be matched by value.
		</p>
		
		<p>
			These last two queries illustrate the equivalence of <i>IN</i> and
			&#61; <i>ANY</i>, but care must be taken if the logical operator <i>NOT</i>
			is added to the outer query, so that it seeks matches with the
			complement of the set for which matches are sought in the original
			query. The operator which is equivalent to <i>NOT IN </i> is not &#60;
			&#62; <i>ANY</i>, as one might initially expect, but rather &#60; &#62;
			<i>ALL</i> - where <i>ALL</i> is another logical operator, which
			evaluates to TRUE if all of a set of comparisons are TRUE - which is
			clear when one thinks through the logic of that query, but perhaps not
			immediately apparent.
		</p>
		
		<p>The most common use for subqueries is to express complicated
			joins in a simpler fashion. Up to 32 levels of nesting are allowed, in
			principle, although memory restrictions may prevent that from being
			achieved in practice. To evaluate a complicated join as a nested series
			of queries would often be much slower, but the database engine should
			recognise the equivalence of the two forms of the query and recast it
			in the most efficient form as part of its query optimisation process.
			So, there should be no difference in the performance of queries
			submitted as complicated joins or as nested subqueries, and the latter
			are to be prefered if they help ensure that the query that is executed
			really is the one that the user wanted to run.</p>
		
		<h3>
			2.5. <a name="Null and default values in the OSA">Null and default
				values in the OSA</a>
		</h3>
		
		<p>
			Our discussion to this point has implicitly assumed that the values of
			the attributes corresponding to each column in every row in a database
			table are known. This need not always be the case, as a simple example
			from the OSA illustrates. The <i>*Source</i> tables in the OSA merges
			information about detections made in the individual frame set images. A
			very blue object may well not be detected in a K band image, so what
			should be written for such an object in the column of the <i>*Source</i>
			table which records, say, the ellipicity of the K band detection? One
			answer would be a <em>null</em> value, which is a special type of entry
			to be included in a table if the value of a given attribute is not
			known (or is indeterminate or is not applicable) for a particular row.
			In designing the OSA we have decided not to use nulls in these cases,
			but to define <em>default</em> values for use in these situations
			instead: e.g. in the example above, we would set the K band ellipticity
			in the <i>*Source</i> table of a celestial object undetected in that
			band to be a recognisably meaningless value; in the case of floating
			point numbers, -0.9999995e9. Nulls and default values are semantically
			different: the query processor in a database management system (DBMS)
			recognises that a value marked as null is unknown or indeterminate and
			will not include it in, say, the computation of the mean value of all
			entries in a column, while, to the query processor, a default value is
			like any other value, and will include it, unless the user explicitly
			excludes it - e.g. by computing the mean magnitude only for those
			objects with magnitudes brighter than -0.9999995e9, in this case. Other
			default values in the OSA include -99999999 for 4- and 8-byte integer
			attributes, -9999 for 2-byte integers, and 0 for 1-byte (unsigned)
			integers. The schema browser generally indicates the default value for
			many of the table attributes, and they have all been chosen to lie well
			beyond the range of legitimate values found in the OSA, so it is simple
			to exclude them:
		</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> <i>AVG</i>(jAperMag3)<br> <i>FROM</i> atlasSource <br>
			<i>WHERE</i> jAperMag3 &gt; 0.0
		
		</div>
		
		<p>
			As a result of defining default values for some columns, there have to
			be dummy rows in some tables (i.e. rows for which every attribute takes
			the appropriate default value). The reason for this is illustrated by
			consideration of the <i>*MergeLog</i> and <i>Multiframe</i> tables in
			the OSA. If one of the multiframe UIDs (e.g. the Y image attribute, <i>ymfID</i>)
			in one of the <i>*MergeLog</i> tables has a default value because that
			particular frame set does not yet have a Y-band image, and if the
			attribute <i>ymfID</i> references the attribute <i>multiframeID</i> in
			table <i>Multiframe</i>, then table <i>Multiframe</i> needs an entire
			row of defaults for <i>multiframeID=-99999999</i> in order to maintain
			the referential integrity of the database.
		</p>
		
		<p>
			It is the responsibility of the user to ensure that the presence of
			default values and dummy rows will not corrupt the results of queries
			run on the OSA, but our decision to use them, rather than nulls greatly
			simplifies the logic involved in <em>all</em> queries run on the
			database. The inclusion of null values for an attribute means that an
			expression involving it can evaluate to <i>TRUE</i>, <i>FALSE</i> or <i>UNKNOWN</i>,
			and we believe that the simplification for users in avoiding this
			three-valued logic greatly outweighs the burden of having to remember
			that default values exist for some columns in the OSA.
		</p>
		
		<br /><br />
		<h2>
			3. <a name="Reference">Reference: additional options in <i>SELECT</i>
				statements
			</a>
		</h2>
		
		<p>
			Previous sections have described the basic <i>SELECT&#8230;FROM&#8230;WHERE&#8230;</i>
			structure of an SQL query. This is the basic syntax to be employed for
			querying the OSA, but there are some additional options in the <i>SELECT</i>
			clause which users may find useful. Once again, a fuller reference than
			is presented below is available online <a
				href="http://msdn2.microsoft.com/en-us/library/ms189826.aspx">
				here</a>.
		</p>
		
		<h3>
			3.1 <a name="Aggregate Functions">Aggregate Functions</a>
		</h3>
		
		<p>SQL offers a number of useful aggregate functions, which can be
			used for deriving summary information on columns or selections from
			them.</p>
		
		<h4>
			3.1.1 <a name="Mathematical aggregate functions">Mathematical
				aggregate functions</a>
		</h4>
		
		<p>
			The meanings of those mathematical aggregate functions which apply only
			to numeric columns are very straightforward: <i>AVG</i>, <i>MAX</i>, <i>MIN</i>,
			<i>SUM</i>, <i>STDEV</i>, <i>STDEVP</i>, <i>VAR</i>, and <i>VARP</i>
			return, respectively, the mean, maximum, minimum, sum, standard
			deviation, population standard variation, variance and population
			variance of all values in the specified column. They can be used in
			conjunction with a <i>WHERE </i>clause or not, i.e.
		</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> max(dec) FROM atlasMergeLog
		</div>
		
		<p>will return the maximum value for the dec column found in the
			atlasMergeLog table, while</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> max(dec) <i>FROM</i> atlasMergeLog <i>WHERE</i> (ra <i>BETWEEN</i>
			180 <i>AND</i> 360)
		
		</div>
		<p>returns the maximum value found for fields within one hemisphere
			of the sky.</p>
		
		<p>
			<i>N.B. </i>Strictly speaking, these functions only apply to <i>non-null</i>
			values found within the particular column. As discussed above, the OSA
			contains no null values by design, but uses default values instead.
			These will not be ignored in the computation of aggregate functions.
			For example, the SQL query
		</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> min(mjdObs) <i>FROM</i> Multiframe
		
		</div>
		<p>
			returns the value -0.9999995e9, which is clearly nonsensical
			astronomically, and just illustrates the unintentional selection of the
			dummy row in the <i>Multiframe</i> table.
		</p>
		
		<h4>
			3.1.2 <a name="COUNT">COUNT</a>
		</h4>
		
		<p>
			There are additional aggregate functions which can be run on columns of
			all types. The most useful of these is <i>COUNT</i>, which can be used
			in a number of ways, as shown in the following example. The <i>programmeID</i>
			attribute in the <i>ProgrammeFrame</i> table identifies the multiframes
			which belong to that programme in the archive: since the OSA combines
			data from several programmes (e.g. the UKIDSS subsurveys), there are
			several different values of <i>programmeID</i>. To find out how many,
			one could use the following query:
		</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT COUNT</i> (<i>DISTINCT</i> programmeID) <i>FROM</i>
			ProgrammeFrame
		</div>
		
		<p>
			In practice, this is best discovered from querying the OSA's <i>Programme</i>
			table. Note that the inclusion of the <i>DISTINCT</i> keyword means
			that only the number of distinct <i>programmeID</i> values was
			returned. If it had been omitted, then the returned value would be the
			total number of entries in the <i>programmeID</i> column, which is
			simply equal to the number of rows in the table, since there are no
			null values for <i>programmeID</i> in the <i>ProgrammeFrame</i> table.
			<br> The total number of rows in the table can be also obtained
			using the following syntax:
		</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT COUNT</i>(*) <i>FROM</i> ProgrammeFrame
		</div>
		<p>
			<u>Using <i>COUNT</i>(*) like this is a very good way of ensuring
				that a query is sensible before getting data returned by running it,
				and users are strongly encouraged to use this method to develop and
				debug SQL queries before running them on the full OSA
			</u>. The performance overhead involved in this two-query process is not as
			high as it might seem, since, depending on how heavily the database is
			being used, some of the data from the <i>COUNT</i>(*) query will still
			be in cache when the query is run a second time to extract the desired
			attributes. Users should note that <i>COUNT</i> should be replaced by <i>COUNT_BIG</i>
			if there is likely to be more than 2x10<sup>9</sup> records to be
			counted: this circumvents an SQL Server bug.
		</p>
		
		<h4>
			3.1.3 <a name="TOP">TOP</a>
		</h4>
		
		<p>
			An interesting function specific to SQL Server&#8217;s SQL dialect is <i>TOP</i>,
			which is illustrated as follows. The query
		</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT TOP</i> 10 mjdObs <i>FROM</i> Multiframe
		
		</div>
		<p>
			would return the MJDs for ten rows in the <i>Multiframe</i> table. This
			will generally <i>not</i> be the ten highest (i.e. most recent) values
			in the table; remember that SQL is a set-based language, so a query
			yields the set of rows satisfying the criteria specified in the query,
			but with, by default, no particular ordering within that set. The ten
			highest area values can be obtained using <i>TOP</i>, however, with the
			addition an <i>ORDER BY</i> clause, which does impose an ordering of
			the rows in the result set: <i>i.e.</i>:
		</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
		
			<i>SELECT TOP</i> 10 mjdObs <i>FROM</i> Multiframe <i>ORDER BY</i>
			mjdObs <i>DESC</i>
		</div>
		<p>
			Note the presence of the <i>DESC</i> (for descending) keyword in the <i>ORDER
				BY</i> clause, which is required because the default behviour is for that
			clause to list rows in ascending order.
		</p>
		
		<h4>
			3.1.4 <a name="Group By and Having"><i>GROUP BY</i> and <i>HAVING</i></a>
		</h4>
		
		<p>
			The <i>GROUP BY</i> clause allows aggregate functions to return more
			than a single value. For example, the user running the "<i>SELECT
				COUNT</i>(<i>DISTINCT</i> programmeID) <i>FROM</i> ProgrammeFrame" query
			above might want to know how many OSA multiframes are associated with
			each programme. That information is returned by the following query:
		</p>
		
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> programmeID, <i>COUNT</i>(*) <i>FROM</i> ProgrammeFrame <i>GROUP
				BY</i> programmeID
		</div>
		<p>
			where the rows in <i>ProgrammeFrame</i> are grouped by their <i>programmeID</i>
			value and separate counts are made of the number of rows in each group.
		</p>
		
		<h3>
			3.2 <a name="Mathematical Functions">Mathematical Functions</a>
		</h3>
		
		<p>The following mathematical functions are supported by SQL
			Server's SQL dialect.</p>
		<ul>
			<li><b>ABS(<i>x</i>):
			</b> returns the absolute value of <i>x</i>.</li>
		
			<li><b>ACOS(<i>x</i>):
			</b> returns the angle, in radians and in the range 0 to &pi;, whose cosine
				is <i>x</i>.</li>
		
			<li><b>ASIN(<i>x</i>):
			</b> returns the angle, in radians and in the range -&pi;/2 to &pi;/2,
				whose sine is <i>x</i>.</li>
		
			<li><b>ATAN(<i>x</i>):
			</b> returns the angle, in radians and in the range -&pi;/2 to &pi;/2,
				whose tangent is <i>x</i>.</li>
		
			<li><b>ATN2(<i>y,x</i>):
			</b> returns the angle, in radians, whose tangent is <i>y/x</i>.</li>
		
			<li><b>CEILING(<i>x</i>):
			</b> returns the smallest integer greater than, or equal to, <i>x</i>.</li>
		
			<li><b>COS(<i>x</i>):
			</b> returns the cosine of angle <i>x</i> in radians.</li>
		
			<li><b>COT(<i>x</i>):
			</b> returns the cotangent of angle <i>x</i> in radians.</li>
		
			<li><b>DEGREES(<i>x</i>):
			</b> returns the angle in degrees corresponding to angle <i>x</i> in
				radians.</li>
		
			<li><b>EXP(<i>x</i>):
			</b> returns the exponential of <i>x</i>.</li>
		
			<li><b>FLOOR(<i>x</i>):
			</b> returns the largest integer less than or equal to <i>x</i>.</li>
		
			<li><b>LOG(<i>x</i>):
			</b> returns the natural logarithm of <i>x</i>.</li>
		
			<li><b>LOG10(<i>x</i>):
			</b> returns the base 10 logarithm of <i>x</i>.</li>
		
			<li><b>PI():</b> returns the value of &pi;.</li>
		
			<li><b>POWER(<i>x</i>,<i>y</i>):
			</b> returns the value of <i>x</i> raised to the power <i>y</i>.</li>
		
			<li><b>RADIANS(<i>x</i>):
			</b> returns the angle in radians corresponding to angle <i>x</i> in
				degrees.</li>
		
			<li><b>RAND(<i>x</i>):
			</b> returns a random number between 0 and 1, using an optional integer
				seed <i>x</i> if supplied.</li>
		
			<li><b>ROUND(<i>x</i>,<i>n</i>,<i>m</i>):
			</b> returns the value of x rounded to a specified length or precision. If
				<i>n</i> is a positive integer, then <i>x</i> is rounded to the number
				of decimal places specified by <i>n</i>. If <i>n</i> is a negative
				integer, then <i>x</i> is rounded <i>n</i> places to the left of the
				decimal point. <i>ROUND</i> can also be used to truncate <i>x</i>,
				through use of the optional argument <i>m</i>. If <i>m</i> is a
				positive integer, then <i>x</i> is truncated to the precision
				specified by <i>n</i>, rather than rounded to it.</li>
		
			<li><b>SIGN(<i>x</i>):
			</b> returns the value 1, 0, -1, depending whether <i>x</i> is positive,
				zero or negative, respectively.</li>
		
			<li><b>SIN(<i>x</i>):
			</b> returns the sine of the angle <i>x</i> in radians.</li>
		
			<li><b>SQUARE(<i>x</i>):
			</b> returns the square of <i>x</i>.</li>
		
			<li><b>SQRT(<i>x</i>):
			</b> returns the positive square root of <i>x</i>.</li>
		
			<li><b>TAN(<i>x</i>):
			</b> returns the tangent of angle <i>x</i> in radians.</li>
		
		</ul>
		<p>Arithmetic functions (such as ABS, CEILING, DEGREES, FLOOR,
			POWER, RADIANS, and SIGN) return a value having the same data type as
			the input value, while trigonometric functions and others (such as EXP,
			LOG, LOG10, SQUARE, and SQRT), cast their input values to float and
			return a float value; this probably is of no concern to the average OSA
			user. All mathematical functions, except for RAND, are deterministic
			functions - i.e. they return the same results each time they are called
			with a specific set of input values - and RAND is deterministic only
			when a seed parameter is specified.</p>
		
		<h3>
			3.3 <a name="Operators">Operators</a>
		</h3>
		
		<p>
			An operator in SQL is a symbol specifying an action that is performed
			on one or more expressions. For the present purposes, their major use
			is to provide greater flexibility in the possible forms of <i>WHERE</i>
			clauses of queries and in the columns of the result sets they can
			produce, which need not simply be columns drawn from the table(s) being
			queried. There are several classes of operator to consider.
		</p>
		
		<h4>
			3.3.1 <a name="Arithmetic operators">Arithmetic operators</a>
		</h4>
		
		<p>
			SQL Server's SQL dialect supports five arithmetic operators. The four
			basic ones - Addition (+), Subtraction (-), Multiplication (*) and
			Division (/) - plus the Modulo operation, (%), which returns the
			remainder of dividing one integer by another, and is used in the format
			"<i>dividend</i>%<i>divisor</i>". The use of the four basic arithmetic
			operators follows straightforwardly from their definitions.
		</p>
		
		<h4>
			3.3.2 <a name="Comparison operators">Comparison operators</a>
		</h4>
		
		<p>
			The Boolean comparison operators are used most frequently to filter
			rows via the <i>WHERE</i> clause of a SQL query. The most simple
			comparison operators ( &lt;, &gt;, =) were used above without
			introduction, but there a total of nine comparison operators which can
			be applied to pairs of expressions in the SQL Server dialect of SQL: =
			(Equal to); &gt; (Greater than); &lt; (Less than); &gt;= (Greater than
			or equal to); &lt;= (Less than or equal to); &lt;&gt;(Not equal to); !=
			(Not equal to); !&gt; (Not greater than); and !&lt; (Not less than).
		</p>
		
		<h4>
			3.3.3 <a name="Logical operators">Logical operators</a>
		</h4>
		
		<p>
			In a similar fashion, we have used a number of the logical operators
			(e.g. <i>AND</i>, <i>BETWEEN</i>, etc) above without introduction, but
			the following is the full list of logical operators supported by SQL
			Server:
		</p>
		<ul>
			<li><b>ALL</b>: TRUE if all of a set of comparisons are TRUE.</li>
			<li><b>AND</b>: TRUE if both of two Boolean expressions are TRUE.</li>
		
			<li><b>ANY</b>: TRUE if at least one of a set of comparisons is
				TRUE.</li>
			<li><b>BETWEEN</b>: TRUE if the operand is within a specified
				range.</li>
			<li><b>EXISTS</b>: TRUE if a subquery contains any rows.</li>
			<li><b>IN</b>: TRUE if the operand is equal to one of a list of
				expressions.</li>
			<li><b>LIKE</b>: TRUE if the operand matches a pattern.</li>
		
			<li><b>NOT</b>: Reverses the value of any other Boolean
				expression.</li>
			<li><b>OR</b>: TRUE if either of a pair of Boolean expressions is
				TRUE.</li>
			<li><b>SOME</b>: TRUE if at least one of a set of comparisons is
				TRUE.</li>
		</ul>
		<p>
			The use of some of these operators (e.g. <i>AND</i>, <i>BETWEEN</i>, <i>OR</i>)
			has been illustrated above, but it is worth making a few comments on
			the remaining ones.
		</p>
		
		<p>
			The <i>LIKE</i> operator is used for pattern matching. This is most
			commonly used for string matching. For example, a user interested in
			knowing how many ATLAS multiframes are present in the OSA could issue
			the query:
		</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT COUNT</i>(*) <i>FROM</i> Multiframe <i>WHERE</i> project <i>LIKE</i>
			"U/UKIDSS/ATLAS%"
		
		</div>
		<p>
			Note the use of the percentage sign wildcard character which matches
			all the UKIRT OMP project strings defined for the ATLAS. Several other
			wildcard characters can be used in conjunction with <i>LIKE</i>; these
			are described further in the <a
				href="http://surveys.roe.ac.uk/ssa/sqlcookbook.html">SSA Cookbook</a>,
			as are further examples of logical operators.
		</p>
		
		<h4>
			3.3.4 <a name="String concatenation operator">String concatenation
				operator</a>
		</h4>
		
		<p>
			The plus sign, &#43;, is used as a string concatenation operator in the
			SQL Server dialect of SQL. This is most likely to be of use to OSA
			users in the formatting of result sets - i.e. in the definition of <i>SELECT</i>
			clauses.
		</p>
		
		<h4>
			3.3.5 <a name="Unary operators">Unary operators</a>
		</h4>
		
		<p>The SQL Server dialect of SQL defines three unary operators -
			i.e. operators which have only one operand - although none of these are
			likely to be of much use to most OSA users. The first of these is the
			positive unary operator, &#43;, which is used principally in SQL
			statements not allowed by the OSA query interface. The second, &#45;,
			is the negative unary operator, which returns the negative value of a
			numeric expression, as shown in the following query:</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> -<i>MIN</i>(decBase) <i>FROM</i> Multiframe <i>WHERE</i>
			MultiframeID &gt; 0
		
		</div>
		<p>
			The final unary operator, &#126;, the Bitwise NOT operator, converts
			each bit in a numeric expression of integer data type into its 1s
			complement (i.e. 0s are changed to 1 and vice versa). This might be of
			use in queries involving the quality flags in the <i>*Source</i> and <i>*Detection</i>
			tables.
		</p>
		
		<h4>
			3.3.6 <a name="Operator precedence">Operator precedence</a>
		</h4>
		
		<p>The operators described in this subsection have the following
			descending levels of precedence:</p>
		
		<ul>
			<li>&#43; (Positive Unary Operator), &#45; (Negative Unitary
				Operator), &#126; (Bitwise NOT)</li>
			<li>&#42; (Multiply), &#47; (Division), &#37; (Modulo)</li>
		
			<li>&#43; (Add), &#43; (Concatenate), &#45; (Subtract), &#38;
				(Bitwise AND)</li>
			<li>&#61; , &#62; , &#60; , &#62; &#61; ,&#60; &#61; , &#60; &#62;
				, &#33; &#61; , &#33; &#62; , &#33; &#60; (Comparison operators)</li>
		
			<li>&#94; (Bitwise Exclusive OR), &#124; (Bitwise OR)</li>
			<li>NOT</li>
			<li>AND</li>
			<li>ALL, ANY, BETWEEN, IN, LIKE, OR, SOME</li>
		</ul>
		<p>When two operators in an expression have the same operator
			precedence level, they are evaluated left to right based on their
			position in the expression.</p>
		
		
		<br /><br />
		<h2>
			4. <a name="crossmatch">How to query cross-matched data in the
				archive</a>
		</h2>
		
		<p>
			Archive catalogue tables are automatically cross-matched to themselves
			and to a number of external survey catalogue datasets held locally,
			e.g. SDSS Data Releases; FIRST, IRAS, ROSAT and 2MASS catalogues; and
			legacy photographic catalogues like USNO-B (for a complete list, click
			on "Browser" on a navigation bar or see below). Rather than prejoining
			any two datasets to create a static, merged table of what are assumed
			to be associated sources on the basis of a fixed joining algorithm, and
			choosing a subset of what are assumed to be useful attributes from each
			of the two catalogue tables to propagate into that merged table, the
			philosophy is to create a table of pointers between any two matched
			datasets. This means, for example, that any externally catalogued
			source co-incident or nearby an archive source is readily available,
			out to some predefined maximum angular search radius, and all sorts of
			science usages are possible because the exact matching criteria (e.g.
			maximum allowable displacement, consistency in morphological parameters
			or classification, or even the number of possible external matches for
			a given archive source) can be tuned at query time by simple
			expressions in SQL. Furthermore, all attributes of both datasets are
			available to querying, because no decision has been made as to which
			attributes to propagate into a static merged set. The flip side to this
			flexibility is the rather opaque syntax for querying cross-matched data
			in SQL: instead of querying a single merged table, e.g. <i>SELECT</i> *
			<i>FROM</i> MergedTable <i>WHERE</i> ..., in general you have to query
			<b>three</b> tables: the two cross-matched tables and the table of
			pointers, e.g. <i>SELECT</i> * <i>FROM</i> Table1, ExternalDB..Table2,
			CrossNeighboursTable2 <i>WHERE</i> ..., using the joining techniques
			discussed above to select out the rows that you require. Some
			real-world examples best illustrate how to query cross-matched data in
			the OSA, but first we discuss the naming of OSA objects (databases,
			tables and attributes) that pertain to catalogue joining.
		</p>
		
		<h3>
			4.1 <a name="Naming convention">Naming convention for tables and
				attributes</a>
		</h3>
		
		<p>
			In OSA parlance, a table of pointers that associates sources within one
			table (i.e. that provides a list of all nearby sources for each source
			within one table) is called a <i>neighbour</i> table, while a table of
			pointers that associates a set of externally catalogued sources to a
			table of VST sources is called a <i>cross-neighbour</i> table.
			Cross-neighbour tables are likely to be used the most, but neighbour
			tables have their uses (for example, you may wish to check the internal
			consistency of VST photometry and astrometry by selecting a set of
			measurements of the same sources in overlap regions of adjacent frame
			sets - this is most easily done using a neighbour table).
		</p>
		
		<p>A list of all available neighbour/cross-neighbour tables is most
			easily obtained as follows:</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
		
			<i>SELECT</i> neighbourTable <i>FROM</i> RequiredNeighbours
		</div>
		<p>
			The naming convention is simple: neighbour tables are named by
			appending the word <i>Neighbours</i> to the source table that they
			point to, e.g. <i>atlasSource</i> has a neighbour table called <i>atlasSourceNeighbours</i>;
			while cross-neighbour tables are named by concatenating the two
			associated table names with an <i>X</i>, e.g. the cross-neighbour table
			between the ATLAS source table and the 2MASS point source catalogue is
			called <i>atlasSourceXtwomass_psc</i>. Within these tables, there will
			always be the following three attributes: <i>masterObjID</i>, which
			points to the source for which neighbours have been created (the
			central source of the neighbourhood, if you like); <i>slaveObjID</i>,
			which points to the neighbouring sources (sources lying within the
			neighbourhood); and finally <i>distanceMins</i> which is the angular
			separation between the central source and the neighbour, in units of
			arcminutes. Depending on the external catalogue joined, there may be
			other attributes in cross-neighbour tables (use the Browser to examine
			these).
		</p>
		
		<p>At the time of writing, external catalogue databases held within
			the OSA consist of:</p>
		<table class="form" border="2">
			<tr>
				<td><b>External survey</b></td>
				<td><b>Catalogue product</b></td>
				<td><b>SQL database name</b></td>
				<td><b>Table name</b></td>
				<td><b>Description</b></td>
			</tr>
			<tr>
		
				<td><a href="http://www.sdss.org/">Sloan Digital Sky Survey</a></td>
				<td>EDR</td>
				<td>SkyServerV3</td>
				<td>PhotoObj</td>
				<td>SDSS Early Data Release (as released in the SkyServer RDBMS
					implementation, not the original SX OODBMS)</td>
			</tr>
		
			<tr>
				<td></td>
				<td>DR5 (3,2)</td>
				<td>BestDR5 (3,2)</td>
				<td>PhotoObj</td>
				<td>SDSS Data Release 5 (3,2)</td>
			</tr>
			<tr>
		
				<td><a href="http://pegasus.phast.umass.edu/">2-Micron
						All-Sky Survey</a></td>
				<td>Point Source Catalogue</td>
				<td>TWOMASS</td>
				<td>twomass_psc</td>
				<td>2MASS point source catalogue</td>
			</tr>
		
			<tr>
				<td></td>
				<td>Extended Source Catalogue</td>
				<td>TWOMASS</td>
				<td>twomass_xsc</td>
				<td>2MASS point source catalogue</td>
			</tr>
			<tr>
		
				<td><a href="http://heasarc.gsfc.nasa.gov/docs/rosat/ass.html">ROSAT
						All Sky Survey </a></td>
				<td>Bright Source Catalogue</td>
				<td>ROSAT</td>
				<td>rosat_bsc</td>
				<td>ROSAT all-sky survey bright source catalogue</td>
			</tr>
		
			<tr>
				<td></td>
				<td>Faint Source Catalogue</td>
				<td>ROSAT</td>
				<td>rosat_fsc</td>
				<td>ROSAT all-sky survey faint source catalogue</td>
			</tr>
			<tr>
		
				<td><a href="http://irsa.ipac.caltech.edu/IRASdocs/iras.html">IRAS</a>
				</td>
				<td>PSC</td>
				<td>IRAS</td>
				<td>iras_psc</td>
				<td>Infra-Red Astronomical Satellite point source catalogue</td>
			</tr>
		
			<tr>
				<td><a href="http://sundog.stsci.edu/">VLA-FIRST</a></td>
				<td>FIRST catalogue</td>
				<td>FIRST</td>
				<td>firstSource</td>
				<td>Faint Images of the Radio Sky at Twenty cm from the VLA
					survey</td>
		
			</tr>
			<tr>
				<td><a href="http://surveys.roe.ac.uk/ssa">SSA</a></td>
				<td>Southern hemisphere survey</td>
				<td>SSA</td>
				<td>Source</td>
				<td>SuperCOSMOS Sky Survey as ingested into the SuperCOSMOS
					Science Archive</td>
		
			</tr>
			<tr>
				<td><a href="http://www.eso.org/~jliske/mgc/">Millenium
						Galaxy Catalogue</a></td>
				<td>MGC</td>
				<td>MGC</td>
				<td>mgcDetection</td>
				<td>37.5 square degree, medium-deep B-band imaging survey</td>
		
			</tr>
			<tr>
				<td><a href="http://www.cv.nrao.edu/nvss/">NRAO VLA Sky
						Survey</a></td>
				<td>NVSS</td>
				<td>NVSS</td>
				<td>nvssSource</td>
				<td>A 1.4 GHz continuum survey covering the entire sky north of
					-40 deg declination.</td>
		
			</tr>
		</table>
		
		<p>Alternatively, you can use the OSA Browser to look at all the
			neighbour tables, their attributes and also the external databases that
			are available in the OSA, or use the following SQL query:</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> surveyName, databaseName, extTableName, description <br>
			<i>FROM</i> ExternalSurvey <i>AS</i> s, ExternalSurveyTable <i>AS</i> t<br>
		
			<i>WHERE</i> s.surveyID=t.surveyID <i>AND</i> s.surveyID&gt;0
		</div>
		
		<h3>
			4.2 <a name="Selecting nearby matches">Selecting nearby
				cross-matches</a>
		</h3>
		
		<p>Suppose a user wishes to select the identifiers and co-ordinates
			of all Faint Source Catalogue sources from the ROSAT All-Sky Survey
			that are within 6 arcsec of a ATLAS source. The SQL to do this is as
			follows:</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> atlas.sourceID, atlas.ra, atlas.dec, fsc.seqNo, fsc.ra,
			fsc.dec <br> <i>FROM</i> atlasSource <i>AS</i> atlas,
			ROSAT..rosat_fsc <i>AS</i> fsc, atlasSourceXrosat_fsc <i>AS</i> x<br>
			<i>WHERE</i> x.masterObjID=atlas.sourceID <i>AND</i>
			x.slaveObjID=fsc.seqNo <i>AND</i> x.distanceMins&lt;0.1
		
		</div>
		<p>
			Note: i) the use of table aliases <i>atlas</i> and <i>fsc</i> which are
			a convenient short-hand; ii) the use of attribute prefixes (e.g. <i>atlas.ra</i>)
			to distinguish between attributes in different tables that happen to
			have the same name; iii) the table joining condition in the <i>WHERE</i>
			clause, which selects associated rows (if you omit this condition, you
			will get all rows of each table joined to all other rows, i.e. an
			extremely large and useless dataset!); and finally iv) the
			specification of a maximum radius of 0.1 arcmin (=6 arcsec) for this
			query, where the maximum available for ROSAT joins is 30 arcsec. You
			can see the maximum joining radii (in arcsec) available to you in each
			neighbour/cross-neighbour table by issuing the following query:
		</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> neighbourTable, joinCriterion*3600.0 as maxRadius <br>
		
			<i>FROM</i> RequiredNeighbours
		</div>
		<p>
			When selecting <i>nearby</i> cross-matches, users should note that one
			or more than one rows may result for each master object, since there
			may be more than one slave neighbour within the neighbourhood defined
			by the maximum join criterion specified. If you want the nearest match
			only, then the next section explains how to do this.
		</p>
		
		<h3>
			4.3 <a name="Selecting the nearest matches">Selecting the nearest
				cross-match</a>
		</h3>
		
		<p>
			Suppose a user wishes to select the infrared and optical point source
			photometry for a sample (say the first 50 rows for speed) in the ATLAS
			and SDSS DR2 overlap, taking the <i>nearest</i> SDSS source to each VST
			source as being the most likely match, where the maximum positional
			tolerance is set to 2 arcsec. The following query will do the job:
		</p>
		
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT TOP</i> 50 atlas.ra, atlas.dec, yAperMag3, jAperMag3,
			hAperMag3, ksAperMag3, psfMag_u, psfMag_g, psfMag_r, psfMag_i, psfMag_z
			<br> <i>FROM</i> atlasSource <i>AS</i> atlas, BestDR2..PhotoObj <i>AS</i>
			dr2, atlasSourceXDR2PhotoObj <i>AS</i> x<br> <i>WHERE</i>
			masterObjID=atlas.sourceID <i>AND</i> slaveObjID=dr2.ObjID <i>AND</i>
			distanceMins&lt;0.033333 <i>AND</i> sdssPrimary=1 <i>AND</i>
			distanceMins <i>IN</i> (<br> <i>SELECT</i> <i>MIN</i>(distanceMins)
			<br> <i>FROM</i> atlasSourceXDR2PhotoObj<br> <i>WHERE</i>
			masterObjID=x.masterObjID <i>AND</i> sdssPrimary=1)
		</div>
		<p>Note the following: i) here, we have used table aliases as
			attribute prefixes only where necessary (i.e. where attributes are not
			unambiguously identified by their names alone); ii) we select "primary"
			objects only from the SDSS, as we are interested in a data set with no
			duplicates; iii) a subquery is used to select the closest neighbour in
			each case, and the main query selects this nearest object if it is
			within the specified 2 arcsec maximum radial tolerance.</p>
		
		<h3>
			4.4 <a name="Selecting neighbours within one table">Selecting
				neighbours within one table</a>
		</h3>
		
		<p>For VST survey tables that have neighbour tables defined, you can
			examine the neighbours of each source in the table. For example,
			suppose we want to check the internal consistency of OSA photometry and
			astrometry by selecting a sample of duplicate source measurements from
			overlap regions between adjacent frame sets in the ATLAS. The following
			query will do the job:</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> (s1.ra-s2.ra)*3600.0*<i>COS</i>(<i>RADIANS</i>(s1.dec))
			as deltaRA, <br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s1.dec-s2.dec)*3600.0
			as deltaDec,<br>
		
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s1.yAperMag3-s2.yAperMag3)
			as dy, <br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s1.jAperMag3-s2.jAperMag3)
			as dj1, <br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s1.hAperMag3-s2.hAperMag3)
			as dh, <br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(s1.ksAperMag3-s2.ksAperMag3)
			as dk <br> <i>FROM</i> atlasSource <i>AS</i> s1, atlasSource <i>AS</i>
			s2, atlasSourceNeighbours <i>AS</i> x<br> <i>WHERE</i>
			s1.yAperMag3 &gt; 0 <i>AND</i> s2.yAperMag3 &gt; 0 <i>AND</i>
			s1.jAperMag3 &gt; 0 <i>AND</i> s2.jAperMag3 &gt; 0 <br>
		
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>AND</i>
			s1.hAperMag3 &gt; 0 <i>AND</i> s2.hAperMag3 &gt; 0 <i>AND</i>
			s1.ksAperMag3 &gt; 0 <i>AND</i> s2.ksAperMag3 &gt; 0<br>
		
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>AND</i>
			masterObjID=s1.sourceID <i>AND</i> slaveObjID=s2.sourceID <i>AND</i>
			s1.priOrSec=s1.frameSetID <i>AND</i> distanceMins&lt;0.01 <i>AND</i>
			distanceMins <i>IN</i> (<br> <i>SELECT</i> <i>MIN</i>(distanceMins)
			<br> <i>FROM</i> atlasSourceNeighbours<br> <i>WHERE</i>
			masterObjID=x.masterObjID)
		</div>
		<p>Note that in this case, a stringent pairing tolerance of 0.6
			arcsec has been set (this corresponds roughly to a 3-sigma chop given
			the typical positional errors in VST astrometry). Also, we have used
			the useful feature of user-defined computed columns to create a tabular
			dataset of attributes that are most useful to us (i.e. differences in
			positions in arcsec and differences in magnitudes in each available
			passband).</p>
	
		
		<br /><br /> 
		<h2>5. <a name="Quality flags">Refining sample selection using quality bit flags</a></h2>
		
		<p>
			Within the detection and source tables there are quality bit flags,
			labelled <i>ppErrBits</i> in the detection tables and <i>*ppErrBits</i>
			in the source tables, where <i>*</i> is the filter name e.g. <i>yppErrBits</i>.
			These attributes encode the quality issues associated with a given
			detection such that detections subject to more serious quality issues
			have higher values. For a detection with no known quality issues the
			attribute's value is zero. The bit flag value encodes up to 32 distinct
			quality issues, which are divided into four different classes according
			to severity. This allows you to select a sample of sources where the
			quality is better than a certain decimal threshold value corresponding
			to each warning classification listed in this table:
		</p>
		
		<table class="form" border="2">
			<tr>
				<td><b>Warning Class</b></td>
				<td><b>Threshold</b></td>
			</tr>
			<tr>
				<td>Information</td>
				<td>256</td>
			</tr>
			<tr>
				<td>Warning</td>
		
				<td>65536</td>
			</tr>
			<tr>
				<td>Important</td>
				<td>16777216</td>
			</tr>
			<tr>
				<td>Severe</td>
				<td></td>
		
			</tr>
		</table>
		<br />
		<p>
			So, to select a sample that consists of sources with no known quality
			issues or just minor, informative, warnings we would add <i>ppErrBits
				&lt; 256</i> to the <i>WHERE </i>clause of our SQL query. This is partly
			how the <i>*PointSource</i> views generate a good quality view of the <i>*Source</i>
			tables for each programme. The reliable<i>*PointSource</i> view selects
			only those sources with no known quality issues. To consider the
			quality information from every passband in your selection, you can
			merge the source table <i>*ppErrBits</i> attributes as: <i>(ksppErrBits
				| hppErrBits | jppErrBits) &lt; 256</i> for as many passbands as exist in
			that programme's source table. As an example of such source selections
			in practice, suppose we want to produce a colour magnitude plot for
			galaxies in the VIDEO source table which have no important quality
			issues:
		</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> ksPetroMag, jmksExt <br> <i>FROM</i> videosSource <i>WHERE</i>
			mergedClass=1 <i>AND</i> ksPetroMag&gt;-9.99995e+8 <i>AND</i>
			jmksExt&gt;-9.99995e+8 <br> <i>AND</i> (jppErrBits | ksppErrBits)
			&lt; 65536
		</div>
		<p>
			Initially one would wish to select just those sources with no known
			quality issues, and then widen the search to include more and more
			potentially spurious sources. To further refine our samples we can
			select or deselect certain quality issues according to their associated
			bit mask, the full list of which may be found in the glossary entries
			for the <a class="ext_links_sqlcookbook" href="#ppErrBits_div"><i>ppErrBits</i></a> attributes. To
			select sources marked with a certain quality issue we would add <i>ppErrBits
				&amp; bitMask != 0</i> to the <i>WHERE </i>clause of our SQL query, where
			<i>bitMask</i> is the bit mask value (decimal or hexadecimal) assigned
			to that quality issue as listed in the <a class="ext_links_sqlcookbook" href="#ppErrBits_div"><i>ppErrBits</i></a>
			glossary entry. Conversely, to exclude a certain quality issue we would
			add <i>ppErrBits &amp; bitMask = 0</i> to the <i>WHERE </i>clause of
			our SQL query.
		</p>
		
		<p>For example, having initially excluded all sources with important
			quality issues, we might wish to include a sample that are within the
			ears of tiles. To do this we just extend the SQL query as follows:</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> ksPetroMag,jmksExt <br> <i>FROM</i> videoSource <i>WHERE</i>
			mergedClass=1 <i>AND</i> ksPetroMag&gt;-9.99995e+8 <i>AND</i>
			jmksExt&gt;-9.99995e+8 <br> <i>AND</i> ((jppErrBits | ksppErrBits)
			&lt; 65536 <i>OR</i> (jppErrBits | ksppErrBits) &amp; 0x00800000 != 0)
		
		</div>
		<p>where the 0x00800000 is the bit mask, in hexadecimal notation,
			that represents the "source in underexposed tile ear" quality issue.</p>
		<p>Finally, to select a sample of galaxies that do not lie within a
			dither offset of the stacked J-band frame boundary (and so contains
			complete data), but can be affected by any other quality issue:</p>
		<div style='border: solid; background-color: #330066;margin-top:10px;margin-bottom:10px;'>
			<i>SELECT</i> ksPetroMag,jmksExt <br> <i>FROM</i> atlasSource <i>WHERE</i>
			mergedClass=1 <i>AND</i> ksPetroMag&gt;-9.99995e+8 <i>AND</i>
			jmksExt&gt;-9.99995e+8 <br> <i>AND</i> jppErrBits &amp; 0x00400000
			= 0
		</div>
		<p>where the 0x00400000 is the bit mask, in hexadecimal notation,
			that represents the "source within a dither offset of the stacked frame
			boundary" quality issue.</p>
		<p>
			Link to <a class="ext_links_sqlcookbook" href="#ppErrBits_div">a fully detailed guide</a> to the
			design of the quality bit flag attribute, <i>ppErrBits</i>, together
			with the complete list of quality issues with full descriptions and
			associated bit masks.
		</p>
		
		<br /><br />
		
		<h2>6. <a name="Filter cover">Refining sample selection for filter coverage</a></h2>
		
		When making selections from the survey merged source tables
		<i>*Source</i>
		, users are reminded to think carefully about their requirements as
		regards filter coverage in the sample. Because releases of survey data
		are made prior to full completion of the surveys (obviously to expedite
		science exploitation), selections will be incomplete in various subtle
		ways depending on exactly how the sample predicates are specified.
		
		<br /><br /><br />
		
	</div>
</div>